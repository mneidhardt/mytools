import xml.etree.ElementTree as etree
import re

# Class that handles various aspects of XML parsing.
#----------------------------------------------------------------------------------------
class XMLParser():
    def __init__(self, file):
        self.NSpattern = re.compile('^\{[^}]+\}(.+)$')
        self.filename = file
        self.root = etree.parse(self.filename).getroot()
    
    def setRootname(self, newname):
        oldname = self.cleanupTag(self.root.tag)
        self.root.tag = newname
        return oldname

    def getAllPaths(self):
        result = self.dfswp(self.root, [])
        return result

    def getAllPaths_xsd(self):
        result = self.dfswp_xsd(self.root, [])
        return result

    def getAllTextContent(self):
        result = self.dfstext(self.root)
        return result

    # Remove NS string.
    def cleanupTag(self, tag):
        match = self.NSpattern.match(tag)
        if match:
            return match.group(1)
        else:
            return tag

    # This goes through an XML file and gathers a dict of all attributes.
    def gatherAllAttribs(self):
        attriblist = self._gatherAllAttribs(self.root)
        
        result = {}
        for elm in attriblist:
            if elm in result:
                result[elm] += 1
            else:
                result[elm] = 1
                
        return result

    # Does the actual work of gathering attributes.
    def _gatherAllAttribs(self, node):
        attriblist = []
        if node is None:
            return attriblist
        else:
            for attr in node.attrib:
                attriblist.append(attr)
        for child in node:
            attriblist.extend(self._gatherAllAttribs(child))
        
        return attriblist
        
    
    # Does depth first traversal, with path.
    # This means that the method saves the full path of every leaf.
    # Returns a list of all leaves with full path.
    def dfswp(self, node, path):
        result = []
        if node is None:
            return result
        else:
            path.append(self.cleanupTag(node.tag))

        if len(node) == 0:
            result.append('/'.join(path))
        else:
            for child in node:
                result.extend(self.dfswp(child, path))
                path.pop()
        
        return result

    def _getAttributes(self, node):
        # Result will contain these elements:
        # 0: minoccurs
        # 1: maxoccurs
        # 2: minlength
        # 3: maxlength
        # 4: primitive type
        # 5: restriction base
        # 6: pattern
        # 7: node text
        
        result = ['1', '1', '', '', '', '', '', '']

        if 'minOccurs' in node.attrib:
            result[0] = node.attrib['minOccurs']
        if 'maxOccurs' in node.attrib:
            result[1] = node.attrib['maxOccurs']
        
        if 'minLength' in node.attrib:
            result[2] = node.attrib['minLength']
        if 'maxLength' in node.attrib:
            result[3] = node.attrib['maxLength']

        if 'primitivetype' in node.attrib:
            result[4] = node.attrib['primitivetype']
        elif 'restrictionbase' in node.attrib:
            result[5] = node.attrib['restrictionbase']

        pattern = ''
        if 'pattern' in node.attrib:
            result[6] = node.attrib['pattern']

        if node.text is not None:
            result[7] = node.text.strip()
        
        return result

    # Does depth first traversal, with path, for XML samples generated from XSDs.
    # The XML is generated by mytools/scripts/xmlparsing/parsexsd.py.
    # The method saves the full path of every leaf,
    # and also adds info on minOccurs, maxOccurs and type.
    # Cardinalities is emitted by adding the (sub)path to result
    # if a node has those attributes and also has kids.
    # Returns a list of all levels and leaves with full path.
    def dfswp_xsd(self, node, path):
        result = []
        if node is None:
            return result
        else:
            path.append(self.cleanupTag(node.tag))

            row = ['/'.join(path)]
            row += [path[-1]]
            row += self._getAttributes(node)
            result.append(';'.join(row))
            
        if len(node) > 0:
            for child in node:
                result.extend(self.dfswp_xsd(child, path))
                path.pop()
        
        return result
      
    def findPath(self, xpath):
        return self.root.findall(xpath)
        
    # Does depth first traversal looking for text content of all nodes.
    # Only text content is returned, in a list.
    def dfstext(self, node):
        result = []
        
        if node is None:
            return result
        else:
            if node.text is not None:
                result.append(node.text)

            for child in node:
                result.extend(self.dfstext(child))
            
            return result
